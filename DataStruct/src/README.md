#### 表的实现

#### 1. 动态数组实现

#### 2. 单链表实现

#### 3. 双链表实现

#### 栈的实现

#### 1. 动态数组实现

#### 2. 单链表实现

单链表实现有两种

1。 一种是以head作为头节点的普通单链表，每一次添加节点都加入到末尾节点，但从始至终head节点位置始终保持不变，始终位于链表头节点；
这样做的优点：是理解简单，容易代码实现，和普通单链表实现没有什么两样，但缺点也很明显，就是每一次push或pop操作，都需要找到最末尾节点，也就是
每一次都要进行一次全表遍历，用图例展示：
```
head.next -> null

push();

head.next-> one
head.next -> one.next -> two

pop();

head.next -> one.next

```

2。另一种使用单链表的形式就是head节点始终指向栈顶元素节点，但next指针指向相反，可以用图例展示：

```
head.next -> null;

push();

head.next-> one;
one.next-> null;

head.next-> two
two.next -> one

head.next-three
three.next -> two.next -> one


pop();

head.next-> two
two.next -> one
```
也就是将指针反向指向，这样做只要一个单链表就可以实现栈

#### 树

#### 二叉树

我们可以看一下演化过程，对于查找算法来说：
一开始是顺序查询，顺序查询的数据结构通常是数组；由于数组本身容量不能动态变化的局限性，我们发展出了链表，可以动态添加节点或删除节点，
很好的解决了扩展的问题；但链表的查询算法复杂度通常也是O(n)，需要遍历整条链表；
再往后，我们发现有序链表或有序数组的情况下，二分查询效率很高，通常是log(n)，但插入就会变慢，有序数组插入每次都需要移动n/2的元素，链表也需要
遍历一条链表之后找到节点，才能实现插入；
为了实现插入的时候也能利用有序这个信息，我们发展出二叉查找树，不仅查询的时候利用二分查询，而且插入的时候也可以利用这个有序的信息，来实现插入效率提升；
但二叉树也会存在问题，即如果插入的数据已经有序，随着不断的查询，二叉树就会一直插入节点左边或右边，进而退化成一条链表，为了解决这个问题，发展出了平衡二叉树，
即在满足二分查询的同时，不断调整树的结构，保证树两边左右子树的深度不相差超过1，避免退化成链表。


#### 散列表


